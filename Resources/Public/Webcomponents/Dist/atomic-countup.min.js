class AtomicCountup extends HTMLElement{constructor(){super(),this._value=0,this._targetValue=0,this._duration=2e3,this._lastTime=null,this._startTime=null,this._precision=0,this._observer=new IntersectionObserver(this._onIntersection.bind(this),{threshold:.1}),this.shadowDom=this.attachShadow({mode:"open"}),this.shadowDom.innerHTML="\n            <style>\n                :host{\n                    display:inline-block;\n                    cursor:pointer;\n                }       \n            </style>\n            <slot></slot>    \n        "}connectedCallback(){this._targetValue=parseFloat(this.getAttribute("value"))||0,this._duration=parseFloat(this.getAttribute("duration"))||2e3,this._precision=parseInt(this.getAttribute("precision"),10)||this._precision,this._easeOut=this.hasAttribute("easeOut"),this._observer.observe(this)}_onIntersection(t){for(let e of t)e.isIntersecting&&(this._observer.disconnect(),this.animate(this._lastTime))}easeOutExpo(t){return 1===t?1:1-Math.pow(2,-20*t)}animate(t){this._startTime||(this._startTime=t);const e=(t-this._startTime)/this._duration,s=this._easeOut?this.easeOutExpo(e):e;this._value=s*this._targetValue,e<1?(this.render(),window.requestAnimationFrame(this.animate.bind(this))):(this._value=this._targetValue,this.render())}render(){this.textContent=parseFloat(this._value.toFixed(this._precision))}}void 0===customElements.get("atomic-countup")&&customElements.define("atomic-countup",AtomicCountup);